<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Dart语言入门 - 時光瓶</title>
<link rel="shortcut icon" href="https://www.shiguangping.com/favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://www.shiguangping.com/media/css/tailwind.css">
<link rel="stylesheet" href="https://www.shiguangping.com/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Dart语言入门 - 時光瓶 - Atom Feed" href="https://www.shiguangping.com/atom.xml">

    

  <meta name="description" content="入口方法
// void 表示没有返回值
void main() {
  print(&#39;你好，Dart&#39;);
}

变量
Dart是强类型语言，变量的数据类型会在初始化时确定。
void main() {
  /**
   * 使用var声..." />
  <meta property="og:title" content="Dart语言入门 - 時光瓶">
  <meta property="og:description" content="入口方法
// void 表示没有返回值
void main() {
  print(&#39;你好，Dart&#39;);
}

变量
Dart是强类型语言，变量的数据类型会在初始化时确定。
void main() {
  /**
   * 使用var声..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://www.shiguangping.com/post/dart-study-1/" />
  <meta property="og:image" content="https://www.shiguangping.com/images/avatar.png">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="Dart语言入门 - 時光瓶">
  <meta name="twitter:description" content="入口方法
// void 表示没有返回值
void main() {
  print(&#39;你好，Dart&#39;);
}

变量
Dart是强类型语言，变量的数据类型会在初始化时确定。
void main() {
  /**
   * 使用var声...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://www.shiguangping.com/post/dart-study-1/">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  
    <link rel="stylesheet" href="https://www.shiguangping.com/media/css/prism-atom-dark.css">
  

  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://www.shiguangping.com" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      時光瓶
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          Dart语言入门
        </h1>
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">2020-12-12 · 33 min read</div>
          
            <a href="https://www.shiguangping.com/tag/rUUIsb33O/" class="text-gray-700 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
              <i class="ri-hashtag"></i>
              Dart
            </a>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <h2 id="入口方法">入口方法</h2>
<pre><code class="language-dart">// void 表示没有返回值
void main() {
  print('你好，Dart');
}
</code></pre>
<h2 id="变量">变量</h2>
<p>Dart是强类型语言，变量的数据类型会在初始化时确定。</p>
<pre><code class="language-dart">void main() {
  /**
   * 使用var声明变量
   * Dart是强类型语言，会通过初始化时赋值的数据类型确定变量的数据类型，且之后不可改变，这与JavaScript不同
   */
  var str = 'Hello Dart';
  var num = 123;

  /**
   * 也可以显示地指定数据类型
   */
  String str1 = 'Hello Dart';
  int num1 = 123;
}
</code></pre>
<p>变量的命名规则：</p>
<ol>
<li>变量名（标识符）必须由字母、数字、下划线或美元符($)组成；</li>
<li>变量名（标识符）开头不能为数字；</li>
<li>变量名（标识符）不能是关键字或保留字；</li>
<li>变量名（标识符）严格区分大小写；</li>
<li>变量名（标识符）要见名知意，建议使用名词；方法名建议使用动词。</li>
</ol>
<p><em>变量名、方法名、类名等统称标识符。</em></p>
<h2 id="常量">常量</h2>
<p>Dart使用<code>const</code>或<code>final</code>关键字声明常量</p>
<pre><code class="language-dart">void main() {
  /**
   * 初始化后不可改变的量叫常量。
   * 
   * 使用 final 或 const 关键字声明常量
   * const 声明常量，声明时必须初始化
   * final 不仅有const编译时常量的特性，最重要的是它是运行时常量。并且final是惰性初始化，即在运行时第一次使用时才初始化
   * 
   */
  const PI = 3.14159;

  // 将一个方法的返回值赋值给一个常量时，使用 final 声明
  final NOW = new DateTime.now();
}
</code></pre>
<h2 id="数据类型">数据类型</h2>
<p>Dart支持以下数据类型：</p>
<p>常用数据类型：</p>
<ul>
<li>数值类型(Numbers)：
<ul>
<li><code>int</code></li>
<li><code>double</code></li>
</ul>
</li>
<li>字符串(String)：
<ul>
<li><code>String</code></li>
</ul>
</li>
<li>布尔类型(Boolean)：
<ul>
<li><code>bool</code></li>
</ul>
</li>
<li>数组（列表）List：
<ul>
<li>在Dart中，数组是列表对象，所以大多数人称它为列表</li>
</ul>
</li>
<li>字典(Map)：
<ul>
<li>键值对</li>
</ul>
</li>
</ul>
<h3 id="字符串拼接">字符串拼接</h3>
<pre><code class="language-dart">void main() {
  var lastName = 'li';
  var firstName = 'yan';
	
  // EL表达式的形式，直接在引号内通过美元符($)引用变量
  print('My name is $lastName $firstName'); // 输出结果：My name is li yan
  
  // 像Java一样使用字符串连接符(+)连接字符串与变量
  print('My name is ' + lastName + ' ' + firstName); // 输出结果：My name is li yan
}
</code></pre>
<h3 id="类型判断">类型判断</h3>
<p>使用<code>is</code>关键字判断变量的类型</p>
<pre><code class="language-dart">void main() {
  var str = 'abc';
  
  if (str is String) {
    print('str是字符串');
  } else {
    print('str不是字符串');
  }
}
</code></pre>
<h3 id="类型转换">类型转换</h3>
<p>字符串转数字</p>
<pre><code class="language-dart">void main() {
  /**
   * String 转成 int 类型数据
   */
  String str1 = '123';
  var num1 = int.parse(str1);
  print(num1); // 输出结果：123

  /**
   * String 转成 double 类型数据
   */
  String str2 = '100.25';
  var num2 = double.parse(str2);
  print(num2); // 输出结果：100.25
}
</code></pre>
<p><code>try-catch</code>抓住异常：</p>
<pre><code class="language-dart">void main() {
  // 假设str为空，在转换成数值时会报错
  String str = '';

  // 使用try-catch抓异常，当try块中的代码发生异常时会执行catch中的语句，catch中的参数err会接收到异常信息
  try {
    var num = double.parse(str);
    print(num);
  } catch (err) {
    var num = 0;
    print(num); // 输出结果：0
  }
}
</code></pre>
<p>数字转字符串：</p>
<pre><code class="language-dart">void main() {
  int num = 123;

  var str = num.toString();

}
</code></pre>
<p>判断字符串是否为空：</p>
<pre><code class="language-dart">void main() {
  
  String str1 = '';
  print(str1.isEmpty); // 输出结果：true
  
}
</code></pre>
<h2 id="list">List</h2>
<p>Dart中的List类似JavaScript中的数组，有序、可变长度、可以存放不同数据类型的元素。可以通过<code>new List()</code>实例化List对象，也可以声明变量的同时直接赋值。</p>
<p>Dart中的List可以在实例化时指定存放元素的数据类型。</p>
<pre><code class="language-dart">void main() {
  // 第一种定义List的方式
  var l1 = ['aaa', 'bbb', 'ccc'];
  print(l1); // 输出结果：[aaa, bbb, ccc]

  // 获取列表(数组)长度 length 属性
  var len = l1.length;
  print(len); // 输出结果：3

  // 获取列表中的元素 通过索引
  var val1 = l1[0];
  var val2 = l1[1];
  print('第一个元素：$val1，第二个元素：$val2'); // 输出结果：第一个元素：aaa，第二个元素：bbb

  // 第二种定义List的方式
  var l2 = new List();

  // 向列表中添加元素 add() 方法
  l2.add('aaa');
  l2.add(123);
  l2.add(true);

  print(l2); // 输出结果：[aaa, 123, true]

  // 指定List的元素类型 泛型
  var l3 = new List&lt;String&gt;();
  l3.add(123); // 会报错，l3中只能存放字符串
  l3.add('abc');
}
</code></pre>
<h2 id="map">Map</h2>
<p>Dart中的Map类似JavaScript中的对象，可以在声明变量的同时直接赋值，也可以通过<code>new Map()</code>的方式实例化Map对象。</p>
<pre><code class="language-dart">void main() {
  // 定义Map：声明变量的同时直接赋值
  var person = {
    'name': '张三',
    'age': 20,
    'lang': ['Java', 'Dart', 'JavaScript']
  };

  print(person); // 输出结果：{name: 张三, age: 20, lang: [Java, Dart, JavaScript]}

  // 从Map中取出元素
  var name = person['name'];
  print(name); // 输出结果：张三

  // 定义Map：使用new Map()实例化Map对象
  var cat = new Map();

  // 向Map中存入元素
  cat['name'] = '花花';
  cat['age'] = 3;
  cat['gender'] = '小母猫';

  print(cat); // 输出结果：{name: 花花, age: 3, gender: 小母猫}
}
</code></pre>
<h2 id="运算符">运算符</h2>
<h3 id="算术运算符">算术运算符</h3>
<p>算术运算符有加<code>+</code>、减<code>-</code>、乘<code>*</code>、除<code>/</code>、取余<code>%</code>、取整<code>~/</code></p>
<pre><code class="language-dart">void main() {
  int a = 13;
  int b = 5;

  // 加
  print(a + b); // 输出结果：18

  // 减
  print(a - b); // 输出结果：8

  // 乘
  print(a * b); // 输出结果：65

  // 除
  print(a / b); // 输出结果：2.6

  // 取余
  print(a % b); // 输出结果：3

  // 取整
  print(a ~/ b); //输出结果：2
}
</code></pre>
<p>自增<code>++</code>和自减<code>--</code>运算符：</p>
<pre><code class="language-dart">// 自增在变量左侧和在变量右侧执行是不一样的
// ++在右，先执行当前语句，再自加
void main() {
  var a = 1;
  print(a++); // 结果：1
}

// ++在左，先自加，再执行当前语句
void main() {
  var a = 1;
  print(++a); // 2
}

// 自减同理
</code></pre>
<h3 id="关系运算符">关系运算符</h3>
<p>关系运算符有等于<code>==</code>、不等于<code>!=</code>、大于<code>&gt;</code>、小于<code>&lt;</code>、大于等于<code>&gt;=</code>、小于等于<code>&lt;=</code></p>
<pre><code class="language-dart">void main() {
  int a = 5;
  int b = 3;

  // 判断是否相等
  print(a == b); // 输出结果：false

  // 判断是否不能
  print(a != b); // 输出结果：true

  // 判断是否大于
  print(a &gt; b); // 输出结果：true

  // 判断是否小于
  print(a &lt; b); // 输出结果：false

  // 判断是否大于等于
  print(a &gt;= b); // 输出结果：true

  // 判断是否小于等于
  print(a &lt;= b); // 输出结果：false
}
</code></pre>
<h3 id="逻辑运算符">逻辑运算符</h3>
<p>逻辑运算符有与<code>&amp;&amp;</code>、或<code>||</code>、非<code>!</code>，其中与、或还有这种形式<code>&amp;</code>、<code>|</code></p>
<pre><code class="language-dart">void main() {
  /**
   * 逻辑运算符有三种：与 &amp;&amp; 、或 || 、非 ！
   */

  bool f1 = true;
  bool f2 = false;

  /**
   * &amp;&amp; 左右两边全部为true时为true，否则为false
   * 
   * &amp;&amp; 短路与：当左边为false时，不再计算符号右边的表达式
   * &amp; ：左右两边都计算
   */
  print(f1 &amp;&amp; f2); // 输出结果：false

  /**
   * || 左右两边有一边为true时为true，两边都是false，则是false
   * 
   * || 短路或：当左边为true时，不再计算符号右边的表达式
   * | ：左右两边都计算
   */
  print(f1 || f2); // 输出结果：true

  /**
   * 非：取反
   */
  print(!f1); // 输出结果：false
  print(!f2); // 输出结果：true
}
</code></pre>
<h3 id="赋值运算符">赋值运算符</h3>
<p>基本的赋值运算符：<code>=</code>、<code>??=</code></p>
<p>复合赋值运算符：<code>+=</code>、<code>-=</code>、<code>*=*</code>、<code>/=</code>、<code>%=</code>、<code>~/=</code></p>
<pre><code class="language-dart">void main() {
  /**
   * 1. 基础赋值运算符
   * 
   * =
   * ??=
   */
  int a = 3;
  int b = 10;

  int c = a + b;

  print(c); // 输出结果：13

  // ??= 当符号左侧变量为null时，将符号右侧的值赋值给符号左侧
  int x;
  x ??= 23;

  print(x); // 输出结果：23

  /**
   * 2. 复合赋值运算符
   * 
   * += -= *= /= %= ~/=
   */
  int i = 5;
  int j = 13;

  // += 先相加，再将结果赋值给符号左边
  print(i += j); // 输出结果：18

  // -= 先相减，再将结果赋值给符号左边
  print(i -= j); // 输出结果：5

  // *= 先相乘，再将结果赋值给符号左边
  print(i *= j); //输出结果：65
}
</code></pre>
<h2 id="流程控制">流程控制</h2>
<h3 id="条件语句">条件语句</h3>
<p><code>if-else</code>：</p>
<pre><code class="language-dart">void main() {
  /**
   * if-else
   */

  int a = 3;
  int b = 5;

  if (a &gt; b) {
    print('max num is $a');
  } else {
    print('max num is $b');
  }
}
</code></pre>
<p>三目运算符：</p>
<pre><code class="language-dart">void main() {
  bool flag = true;

  /**
   * 条件表达式 ? 表达式为真时 : 表达式为假时
   */
  var str = flag ? 'flag = true' : 'flag = false';

  print(str); // 输出结果：flag = true
}
</code></pre>
<p><code>??</code>运算符：</p>
<pre><code class="language-dart">void main() {
  var a;

  /**
   * ??左侧不为空时将左侧赋值给变量b，否则将??右侧的值赋值给变量b
   */
  var b = a ?? 10;

  print(b);
}
</code></pre>
<h3 id="循环语句">循环语句</h3>
<p>for循环：</p>
<pre><code class="language-dart">void main() {
  var sum = 0;

  // for (声明变量; 条件表达式; 循环体执行完一次后执行) { 循环体 }
  for (var i = 0; i &lt;= 100; i++) {
    sum += i;
  }

  print('0-100的累加和：$sum'); // 5050
}
</code></pre>
<p>while循环：</p>
<pre><code class="language-dart">void main(List&lt;String&gt; args) {
  var sum = 0;
  var i = 0;
  
  while (i &lt;= 100) {
    sum += i;
    i++;
  }

  print('0-100的累加和：$sum'); // 5050
}
</code></pre>
<p>do-while循环：</p>
<pre><code class="language-dart">void main(List&lt;String&gt; args) {
  var sum = 0;
  var i = 0;

  do {
    sum += i;
    i++;
  } while (i &lt;= 100);

  print('0-100的累加和：$sum'); // 5050
}
</code></pre>
<p>do-while是先执行再判断</p>
<h4 id="break-关键字">break 关键字</h4>
<ol>
<li>在switch语句中是流程跳出switch结构；</li>
<li>在循环语句中，终止循环。嵌套循环结构中，只会终止当前一层循环，外层循环继续执行；</li>
<li>break可用在switch-case中，也可用在for循环、while循环中。</li>
</ol>
<h2 id="集合">集合</h2>
<h3 id="list-2">List</h3>
<pre><code class="language-dart">abstract class List&lt;E&gt; implements EfficientLengthIterable&lt;E&gt;{...}
</code></pre>
<p>Dart中的List实现了EfficientLengthIterable抽象类，该抽象类继承了Iterable抽象类。</p>
<p>定义集合</p>
<pre><code class="language-dart">List fruits = ['西瓜','苹果','哈密瓜'];
</code></pre>
<p>或者</p>
<pre><code class="language-dart">var fruits = new List();
fruits.add('橘子');
</code></pre>
<p>常用属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>length</td>
<td>返回int类型的集合长度（元素个数）</td>
</tr>
<tr>
<td>isEmpty</td>
<td>判读集合是否为空，返回bool</td>
</tr>
<tr>
<td>isNotEmpty</td>
<td>判断集合是否不为空，返回bool</td>
</tr>
<tr>
<td>reversed</td>
<td>翻转集合</td>
</tr>
</tbody>
</table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>add(E value)</td>
<td>在集合尾部添加元素</td>
</tr>
<tr>
<td>addAll(Iterable<E> iterable)</td>
<td>在集合尾部添加一个集合</td>
</tr>
<tr>
<td>indexOf(E element)</td>
<td>返回元素在集合中的索引值，元素不存在返回-1</td>
</tr>
<tr>
<td>remove(Object? value)</td>
<td>移除集合中的元素，元素不存在返回false</td>
</tr>
<tr>
<td>removeAt(int index)</td>
<td>通过索引移除集合中的元素，返回被移除的元素</td>
</tr>
<tr>
<td>fillRange(int start, int end, [E? fillValue])</td>
<td>修改从起始到结束前一个的所有元素，如(0,1,'aaa'),是将集合中的第一个元素修改为aaa</td>
</tr>
<tr>
<td>insert(int index, E element)</td>
<td>在指定索引处插入元素</td>
</tr>
<tr>
<td>insertAll(int index, Iterable<E> iterable)</td>
<td>在指定索引处插入一个集合</td>
</tr>
<tr>
<td>join([String separator = &quot;&quot;])</td>
<td>将集合转为字符串，参数列表传入分隔符</td>
</tr>
</tbody>
</table>
<p>字符串转为<code>List&lt;String&gt;</code>数组</p>
<pre><code class="language-dart">var str = 'aaa,bbb,ccc';
var arr = str1.split(',');
</code></pre>
<h3 id="set">Set</h3>
<p>Set通用继承EfficientLengthIterable抽象类，不同点在于它无序，且不能存入重复元素。</p>
<p>List集合元素去重：</p>
<pre><code class="language-dart">void main(List&lt;String&gt; args) {
  List fruits = [
    '西瓜',
    '苹果',
    '哈密瓜',
    '西瓜',
    '苹果',
  ];

  var s = fruits.toSet();
  print(s); // {西瓜, 苹果, 哈密瓜}
}
</code></pre>
<h3 id="map-2">Map</h3>
<p>Map是一种<code>key:value</code>的数据</p>
<p>定义Map</p>
<pre><code class="language-dart">var person = {'name': '张三', 'age': 17, 'gender': '男'};
</code></pre>
<p>或者</p>
<pre><code class="language-dart">var person = new Map();

info['name'] = '张三';
info['age'] = 17;
info['gender'] = '男';
</code></pre>
<p>常用属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>keys</td>
<td>返回Map中的所有key值，返回<code>Iterable&lt;K&gt;</code>类型数据</td>
</tr>
<tr>
<td></td>
<td>返回Map中的所有value值，返回<code>Iterable&lt;K&gt;</code>类型数据</td>
</tr>
<tr>
<td>isEmpty</td>
<td>判断Map是否为空，返回bool</td>
</tr>
<tr>
<td>isNotEmpty</td>
<td>判断Map是否不为空，返回bool</td>
</tr>
</tbody>
</table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">addAll(Map&lt;K, V&gt; other)</td>
<td>添加键值对</td>
</tr>
<tr>
<td style="text-align:left">remove(Object? key)</td>
<td>通过key移除Map中的键值对，返回被移除的value</td>
</tr>
<tr>
<td style="text-align:left">containsKey(Object? key)</td>
<td>判断Map中是否包含指定key</td>
</tr>
<tr>
<td style="text-align:left">containsValue(Object? value)</td>
<td>判断Map中是否包含指定value</td>
</tr>
</tbody>
</table>
<h3 id="遍历集合">遍历集合</h3>
<p>for循环</p>
<pre><code class="language-dart">void main() {
  List list = ['Appli', 'Google', 'Microsoft'];

  for (int i = 0; i &lt; list.length; i++) {
    print(list[i]);
  }
}
</code></pre>
<p>for-in循环</p>
<pre><code class="language-dart">void main() {
  List list = ['Appli', 'Google', 'Microsoft'];

  for (var item in list) {
    print(item);
  }
}
</code></pre>
<p>集合类型提供的foreach方法</p>
<pre><code class="language-dart">void main() {
  List list = ['Apple', 'Google', 'Microsoft'];

  list.forEach((element) {
    print(element);
  });
}
</code></pre>
<h4 id="map方法">map方法</h4>
<p>映射集合的每一个元素，将处理后的元素返回成一个Iterable类型数据</p>
<pre><code class="language-dart">void main() {
  List list = ['Apple', 'Google', 'Microsoft'];

  var res = list.map((e) =&gt; e == 'Google' ? e = 'Tencent' : e).toList();

  print(res); // [Apple, Tencent, Microsoft]
}
</code></pre>
<h4 id="where方法">where方法</h4>
<p>将满足条件的元素返回成一个Iterable类型数据</p>
<pre><code class="language-dart">void main() {
  List list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];

  var res = list.where((e) =&gt; e &gt;= 5).toList();

  print(res); // [5, 6, 7, 8, 9]
}
</code></pre>
<h4 id="any方法">any方法</h4>
<p>集合中有任一元素满足指定条件，则返回true</p>
<pre><code class="language-dart">void main() {
  List list = ['Apple', 'Google', 'Microsoft'];

  var res = list.any((e) =&gt; e.toString().length &gt; 7);

  print(res);
}
</code></pre>
<h4 id="every方法">every方法</h4>
<p>集合中每个元素都满足指定条件，才返回true</p>
<pre><code class="language-dart">void main() {
  List list = ['Apple', 'Google', 'Microsoft'];

  var res = list.every((e) =&gt; e.toString().length &gt; 6);

  print(res);
}
</code></pre>
<h2 id="函数方法">函数（方法）</h2>
<p>Dart中的方法可以定义在任意位置，方法内和外面都可以定义方法，定义位置不同，作用域也不同。</p>
<p>方法定义格式：</p>
<pre><code class="language-dart">返回值类型 方法名 (参数列表) {
  方法体
}
</code></pre>
<p>如果方法没有返回值，则返回值类型为<code>void</code>，返回值类型可以省略不写。</p>
<p>方法名的命名规范：小驼峰，即一个单词时使用小写，多个单词组成时，第一个单词小写，其余单词首字母大写。如 fetch() 、findAll() ...</p>
<h4 id="带有参数列表的方法">带有参数列表的方法</h4>
<pre><code class="language-dart">void main() {
  var sum = plus(10, 5);
  print(sum);
}

/**
 * 返回a+b
 */
int plus(int a, int b) {
  return a + b;
}
</code></pre>
<h4 id="带有可选参数的方法">带有可选参数的方法</h4>
<p>参数列表中可以使用<code>[]</code>定义可选参数，可选参数可以定义多个，且只能定义在其它参数后面。</p>
<pre><code class="language-dart">void main() {
  var info = getInfo('张三', '男');
  print(info); // 姓名：张三，性别：男，年龄：保密
}

/**
 * 返回info
 */
String getInfo(String name, String gender, [int age]) {
  var age1 = age ?? '保密';
  return &quot;姓名：$name，性别：$gender，年龄：$age1&quot;;
}
</code></pre>
<h4 id="带有默认参数的方法">带有默认参数的方法</h4>
<p>可选参数可以设置默认值。</p>
<pre><code class="language-dart">void main() {
  var info = getInfo('张三');
  print(info); // 姓名：张三，性别：男，年龄：保密
}

/**
 * 返回info
 */
String getInfo(String name, [String gender = '男', int age]) {
  var age1 = age ?? '保密';
  return &quot;姓名：$name，性别：$gender，年龄：$age1&quot;;
}
</code></pre>
<h4 id="带有命名参数的方法">带有命名参数的方法</h4>
<p>使用<code>{}</code>定义命名参数，命名参数与可选参数类似，都可以选择性的传参，但传参方式上有区别，需要按照<code>参数名:参数值</code>的形式传参。</p>
<pre><code class="language-dart">void main() {
  var info = getInfo('小野', gender: '女', age: 23);
  print(info); // 姓名：小野，性别：女，年龄：23
}

/**
 * 返回info
 */
String getInfo(String name, {String gender = '男', int age}) {
  var age1 = age ?? '保密';
  return &quot;姓名：$name，性别：$gender，年龄：$age1&quot;;
}
</code></pre>
<h4 id="把方法当做参数传给一个方法">把方法当做参数传给一个方法</h4>
<pre><code class="language-dart">void main() {
  func1() {
    print('我是func1');
  }

  func2(func) {
    // 调用传入的方法
    func();
  }

  func2(func1);
}
</code></pre>
<h4 id="匿名方法">匿名方法</h4>
<pre><code class="language-dart">void main() {
  printNum(123); // 通过变量名调用匿名方法
}

// 匿名方法 赋值给变量printNum
var printNum = (int n) {
  print(n);
};
</code></pre>
<h4 id="自执行方法">自执行方法</h4>
<pre><code class="language-dart">void main() {
  (() {
    print('自执行方法');
  })();
}
</code></pre>
<p>传参</p>
<pre><code class="language-dart">void main() {
  ((int n) {
    print(n);
  })(123);
}
</code></pre>
<h4 id="方法递归">方法递归</h4>
<p>通过方法递归计算0-100的累加和</p>
<pre><code class="language-dart">void main() {
  int sum = 0;

  plus(n) {
    sum += n;

    if (n == 100) {
      return;
    }
    plus(n + 1);
  }

  plus(1);

  print(sum); // 5050
}
</code></pre>
<h4 id="闭包">闭包</h4>
<p>全局变量：全局变量常驻内存，全局变量污染全局；</p>
<p>去不变量：局部变量不会常驻内存，会被垃圾回收机制回收，并且不会污染全局。</p>
<p>如果我们既想让一个变量常驻内存，又不想让它污染全局，这时就产生了闭包。</p>
<p>闭包的写法：方法中嵌套方法，并return里面的方法。</p>
<pre><code class="language-dart">void main() {
  func() {
    int a = 1;
    return () {
      a++;
      print(a);
    };
  }

  var f = func();
  f(); // 2
  f(); // 3
  f(); // 4
}
</code></pre>
<h2 id="类-对象">类 对象</h2>
<p>面向对象的三大特性：封装、继承、多态。</p>
<blockquote>
<p>封装：将有共同状态和行为的事物封装成抽象的类；</p>
<p>继承：Dart是单继承，可以继承父类的属性和方法；</p>
<p>多态：</p>
</blockquote>
<p>在Dart中，一切皆对象，即便是基本数据类型（int、double ...）都是类，所有的类最终都继承自<code>Object</code>类。</p>
<p>Dart是一门使用类和单继承的语言，这一点和Java等类似。所有的对象都是类的实例，并且所有的类都是Object类的子类。</p>
<p>一个类通常由属性和方法组成。</p>
<h3 id="实例化">实例化</h3>
<p>在学习面向对象中，有这么一句话，<code>对象是类的实例，类是对象的抽象</code>。因为类是抽象的，所以我们需要把它实例化成对象，再使用类中的属性和方法。</p>
<pre><code class="language-dart">List list = new List(); // 通过new关键字实例化对象

list.length; // 通过List的对象调用其属性及方法
list.add('dart');
</code></pre>
<p><em>在Dart语言中，实例化对象时，new关键字可以省略。</em></p>
<h3 id="定义类">定义类</h3>
<p>使用<code>class</code>关键字定义类。类名的命名规范：大驼峰，所有单词的首字母均大写。</p>
<pre><code class="language-dart">class 类名 {
  ...
}
</code></pre>
<p>::: details Demo</p>
<pre><code class="language-dart">void main() {
  // 实例化Person
  var zs = new Person();
  zs.name = '张三';
  zs.age = 17;
  String info = zs.getInfo();
  print(info);
}

class Person {
  // 属性
  String name;
  int age;

  // 方法
  String getInfo() {
    return &quot;姓名：$name，年龄：$age。&quot;;
  }
}
</code></pre>
<p>:::</p>
<h3 id="默认构造函数">默认构造函数</h3>
<p>构造方法：方法名与类名相同。</p>
<p>构造方法在类实例化时被调用，即<code>new 类名()</code>时调用。</p>
<pre><code class="language-dart">void main() {
  // 实例化时会调用类中的构造函数
  Person p = new Person('张三', 17);
  p.getInfo();
}

class Person {
  String name;
  int age;

  // 默认构造函数
  Person(String name, int age) {
    this.name = name;
    this.age = age;
  }

  getInfo() {
    print(&quot;name: $name, age: $age.&quot;);
  }
}
</code></pre>
<p>构造函数简写：</p>
<pre><code class="language-dart">void main() {
  // 实例化时会调用类中的构造函数
  Person p = new Person('张三', 17);
  p.getInfo();
}

class Person {
  String name;
  int age;

  // 构造函数简写
  Person(this.name, this.age);

  getInfo() {
    print(&quot;name: $name, age: $age.&quot;);
  }
}
</code></pre>
<h3 id="命名构造函数">命名构造函数</h3>
<pre><code class="language-dart">void main() {
  // 调用类中的命名构造函数
  Person p = new Person.now();
}

class Person {
  String name;
  int age;

  // 默认构造函数
  Person(this.name, this.age);

  // 命名构造函数
  Person.now() {
    print('我是命名构造函数');
  }

  getInfo() {
    print(&quot;name: $name, age: $age.&quot;);
  }
}
</code></pre>
<h3 id="引入dart文件">引入dart文件</h3>
<p>使用<code>import</code>关键字引入外部dart文件。</p>
<pre><code class="language-dart">import 'lib/Person.dart';

void main() {
  // 调用类中的命名构造函数
  Person p = new Person.now();
}
</code></pre>
<p>::: details /lib/Person.dart</p>
<pre><code class="language-dart">class Person {
  String name;
  int age;

  // 默认构造函数
  Person(this.name, this.age);

  // 命名构造函数
  Person.now() {
    print('我是命名构造函数');
  }

  getInfo() {
    print(&quot;name: $name, age: $age.&quot;);
  }
}
</code></pre>
<p>:::</p>
<h3 id="私有属性-私有方法">私有属性 私有方法</h3>
<p>Dart语言中定义私有属性和私有方法，在属性名和方法名前加上<code>_</code>下划线，来定义私有。</p>
<p>如 _name 、_age ... 。</p>
<pre><code class="language-dart">class Person {
  // _ 定义私有属性
  String _name;
  int _age;

  Person(this._name, this._age);
  
  // getter方法
  get name {
    return this._name;
  }

  get age {
    return this._age;
  }
  
  // setter方法
  set name(String name) {
    this._name = name;
  }

  set age(int age) {
    this._age = age;
  }
  	
  // 私有方法
  String _getInfoStr() {
    return &quot;name: $_name, age: $_age.&quot;;
  }

  getInfo() {
    print(_getInfoStr());
  }
}
</code></pre>
<p>如上代码，在Dart语言中，getter方法和setter方法是通过<code>get</code>关键字和<code>set</code>关键字定义的。</p>
<h3 id="类中的初始化列表">类中的初始化列表</h3>
<p>带有初始化列表的构造函数，会在实例化对象之前为属性赋值。</p>
<pre><code class="language-dart">class Person {
  String _name;
  int _age;

  // 带有初始化列表的构造函数
  Person()
      : _name = '张三',
        _age = 18;

  getInfo() {
    print(&quot;name: $_name, age: $_age.&quot;);
  }
}
</code></pre>
<h3 id="static-关键字">static 关键字</h3>
<p>使用<code>static</code>关键字修饰的属性成为“静态属性”，修饰的方法成为“静态方法”。</p>
<p>在静态方法中不能直接访问非静态的属性或方法，在非静态方法中，可以直接访问静态属性和静态方法。</p>
<p>静态属性或方法可以直接通过<code>类名.属性名</code>、<code>类名.方法名()</code>的形式调用。</p>
<p>静态属性也成为类属性，全局共享。</p>
<pre><code class="language-dart">void main() {
  // 通过类名直接调用
  Person.gender = '女';
  Person.printDemo();
}

class Person {
  String name;
  int age;
  static String gender; // 静态属性

  // 静态方法
  static printDemo() {
    print('I am static method. I am $gender');
  }

  printInfo() {
    print('name: $name, age: $age, gender: $gender.');
  }
}
</code></pre>
<h3 id="对象操作符">对象操作符</h3>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>?</td>
<td>条件运算符</td>
</tr>
<tr>
<td>as</td>
<td>类型装换</td>
</tr>
<tr>
<td>is</td>
<td>类型判断</td>
</tr>
<tr>
<td>..</td>
<td>级联操作（连缀）</td>
</tr>
</tbody>
</table>
<p>条件运算符 <code>?</code></p>
<pre><code class="language-dart">void main() {
  Person p; // 声明了一个Person类型的空引用，没有指向具体实例
  p = new Person('张三', 17);

  p?.printInfo(); // 如果p为null，不调用方法
}

class Person {
  String name;
  int age;

  Person(this.name, this.age);

  printInfo() {
    print('name: $name, age: $age.');
  }
}
</code></pre>
<p>类型判断 <code>is</code></p>
<pre><code class="language-dart">void main() {
  var p = new Person('张三', 17);

  bool res = p is Person; // 判断对象是否属于Person类型
  print(res);
}

class Person {
  String name;
  int age;

  Person(this.name, this.age);

  printInfo() {
    print('name: $name, age: $age.');
  }
}
</code></pre>
<p>类型转换 <code>as</code></p>
<pre><code class="language-dart">void main() {
  // 父类引用指向子类实例(向上转型)，父类引用o只能调用父类中的方法以及子类重写父类的方法
  Object o = new Person('张三', 17);

  // 如果想调用子类独有的方法，需要向下转型成Person类型，才能调用
  (o as Person).printInfo();
}

class Person {
  String name;
  int age;

  Person(this.name, this.age);

  printInfo() {
    print('name: $name, age: $age.');
  }
}
</code></pre>
<p>面向对象的多态性：</p>
<ul>
<li>父类引用(对象)指向子类实例，称为向上转型(自动转型、隐式转型)</li>
<li>子类引用指向父类实例，称为向下转型(强制转型、显示转型)</li>
</ul>
<p>如果要将父类对象转为子类类型，用到<code>as</code>关键字。</p>
<p>连缀操作 <code>..</code></p>
<pre><code class="language-dart">void main() {
  Person p = new Person('张三', 17);

  // 连缀操作
  p
    ..name = '李四'
    ..age = 19
    ..printInfo();
}

class Person {
  String name;
  int age;

  Person(this.name, this.age);

  printInfo() {
    print('name: $name, age: $age.');
  }
}
</code></pre>
<h3 id="继承">继承</h3>
<p>Dart语言中的继承：</p>
<ul>
<li>子类使用<code>extends</code>关键字类继承父类；</li>
<li>子类可以继承父类可见的属性和方法，但不会继承构造函数；</li>
<li>子类能复写父类的方法 getter 和 setter</li>
</ul>
<pre><code class="language-dart">void main() {
  Person p = new GoodMan('张三', 17);
  p.printInfo();
}

class Person {
  String name;
  int age;

  Person(this.name, this.age);

  printInfo() {
    print('name: $name, age: $age.');
  }
}

class GoodMan extends Person {
  String flag;

  // 在子类实例化时默认会调用父类的构造函数，父类中含有有参的构造函数，所以在子类的构造函数中要通过super关键字调用父类的构造器为属性赋值
  GoodMan(String name, int age) : super(name, age);
	
  // 重写父类的方法
  @override
  printInfo() {
    print('name: $name, age: $age, I am a goods man.');
  }
}
</code></pre>
<h3 id="抽象类">抽象类</h3>
<p>Dart中的抽象类：Dart抽象类主要用于定义标准，子类可以继承抽象类，也可以实现抽象类接口。</p>
<ul>
<li>抽象类通过<code>abstract</code>关键字类定义；</li>
<li>Dart中的抽象方法不能使用<code>abstract</code>关键字声明，这一点和Java不同。在Dart中没有方法体的方法我们称为抽象方法，且只能在抽象类中定义抽象方法；</li>
<li>如果子类继承(<code>entends</code>)一个抽象类，则必须实现抽象类里面的全部抽象方法；</li>
<li>如果把抽象类当做接口实现(<code>implements</code>)的话，则必须要实现抽象类中定义的所有属性和方法。</li>
<li>抽象类不能被实例化。</li>
</ul>
<p><code>extends</code>和<code>implements</code>关键字的用法：</p>
<ul>
<li>如果要复用抽象类里面的方法，并且要用抽象方法约束子类的话，一般使用<code>extends</code>继承抽象类；</li>
<li>如果把抽象类当做定义标准的话，一般使用<code>implements</code>实现抽象类。</li>
</ul>
<pre><code class="language-dart">void main() {
  Animal dog = new Dog();
  Animal cat = new Cat();
  dog.eat(); // 小狗喜欢啃骨头
  cat.eat(); // 小猫爱吸猫薄荷
  cat.printInfo(); // 我是抽象类中的普通方法
}

abstract class Animal {
  // 没有方法体的方法是抽象方法，且抽象方法只能在抽象类中定义
  eat();

  // 普通方法
  printInfo() {
    print('我是抽象类中的普通方法');
  }
}

class Dog extends Animal {
  // 子类必须重写父类（抽象类）中的抽象方法
  @override
  eat() {
    print('小狗喜欢啃骨头');
  }
}

class Cat extends Animal {
  @override
  eat() {
    print('小猫爱吸猫薄荷');
  }
}
</code></pre>
<h3 id="多态">多态</h3>
<p>Dart中的多态：</p>
<ul>
<li>允许将子类类型的指针赋值给父类类型的指针，同一个函数调用会有不同的执行结果；</li>
<li>也就是将子类实例指向（赋值给）父类引用（对象），父类对象调用同一个被不同子类重写的方法会有不同的执行结果；</li>
<li>多态就是父类定义一个方法，继承它的子类重写该方法，每个子类有不同的表写，即对象的多态性。</li>
</ul>
<pre><code class="language-dart">void main() {
  // 父类引用指向子类实例（向上转型），父类对象调用被子类重写的方法得到不同的执行结果，表现了对象的多态性
  Animal dog = new Dog();
  Animal cat = new Cat();
  dog.eat(); // 小狗喜欢啃骨头
  cat.eat(); // 小猫爱吸猫薄荷
}

abstract class Animal {
  // 抽象方法
  eat();
}

class Dog extends Animal {
  @override
  eat() {
    print('小狗喜欢啃骨头');
  }
}

class Cat extends Animal {
  @override
  eat() {
    print('小猫爱吸猫薄荷');
  }
}
</code></pre>
<blockquote>
<p>注意：</p>
<p>父类引用（对象）指向子类实例，此时父类引用只能调用父类独有的方法以及子类重写父类的方法，<strong>不能</strong>调用子类独有的方法。</p>
<p>如果要调用子类独有的方法，需要将父类引用强制转换（向下转型）成子类类型，才能调用子类中的方法。</p>
</blockquote>
<pre><code class="language-dart">void main() {
  Animal dog = new Dog();
  // 父类对象只能调用父类独有或者子类重写父类的方法
  dog.eat(); // 小狗喜欢啃骨头

  // 需要将Animal类型转型Dog类型，才能调用Dog中的run()方法
  (dog as Dog).run(); // 小狗喜欢跑
}

abstract class Animal {
  // 抽象方法
  eat();
}

class Dog extends Animal {
  @override
  eat() {
    print('小狗喜欢啃骨头');
  }

  // 子类独有的方法
  run() {
    print('小狗喜欢跑');
  }
}
</code></pre>
<h3 id="接口">接口</h3>
<p>Dart语言中有接口，但是没有定义接口的关键字，如<code>interface</code>。普通类和抽象类都可以作为接口被实现。实现接口的关键字是<code>implements</code>。</p>
<p>Dart中，如过要实现一个普通类或者抽象类，则需要重写其所有的属性和方法。</p>
<p>因为抽象类中可以定义抽象方法，所以一般使用抽象类来定义接口。</p>
<pre><code class="language-dart">class Animal {
  String name;
  int age;

  eat() {
    print('动物会吃东西');
  }
}

// 实现Animal类，需要重写其所有的属性和方法
class Dog implements Animal {
  @override
  int age;

  @override
  String name;

  @override
  eat() {
    // TODO: implement eat
    throw UnimplementedError();
  }
}
</code></pre>
<h3 id="实现多个接口">实现多个接口</h3>
<pre><code class="language-dart">abstract class A {
  String name;
  printA();
}

abstract class B {
  printB();
}

// 可以实现多个接口，并需要重写实现接口的所有属性和方法
class C implements A, B {
  @override
  String name;

  @override
  printA() {
    // TODO: implement printA
    throw UnimplementedError();
  }

  @override
  printB() {
    // TODO: implement printB
    throw UnimplementedError();
  }
}
</code></pre>
<h3 id="mixins">mixins</h3>
<p><code>mixins</code>的中文意思是“混入”，就是在类中混入其他功能。</p>
<p>在Dart语言中，可以使用mixins实现类似多继承的功能。</p>
<p>因为mixins使用的条件随着Dart版本一直在变，这里讲的是Dart 2.x中使用mixins的条件：</p>
<ul>
<li>作为mixins的类只能继承自Object，不能继承其他类；</li>
<li>作为mixins的类不能有构造函数；</li>
<li>一个类可以mixins多个类；</li>
<li>mixins绝不是继承，也不是接口，而是一种全新的特性 ；</li>
<li>使用<code>with</code>关键字mixins其他类；</li>
<li>继承和mixins可以同时使用，即一个类可以<code>extends</code>一个类同时<code>with</code>多个类；</li>
<li>mixins的多个类中有同名的方法，在调用时会执行<code>with</code>靠后类中的方法，后面会把前面同名的方法覆盖掉。</li>
</ul>
<pre><code class="language-dart">class A {
  printA() {
    print('A');
  }
}

class B {
  printB() {
    print('B');
  }
}

// 使用 with 关键字 mixins其他类
class C with A, B {}

void main() {
  var c = new C();

  c.printA();
  c.printB();
}
</code></pre>
<h2 id="泛型">泛型</h2>
<p>泛型就是解决类、接口、方法的复用性以及对不特定数据类型的支持（数据校验）。</p>
<h3 id="泛型方法">泛型方法</h3>
<pre><code class="language-dart">// 定义泛型方法 T表示泛型 可以用任意字母代替，一般用大写字母T
T getData&lt;T&gt;(T value) {
  return value;
}

void main() {
  // 在调用时可以指定T的具体类型
  var res1 = getData&lt;int&gt;(123);
  var res2 = getData&lt;String&gt;('dart');

  print(res1);
  print(res2);
}
</code></pre>
<h3 id="泛型类">泛型类</h3>
<pre><code class="language-dart">void main() {
  // 在实例化时指定泛型的具体类型
  var myList = new MyList&lt;String&gt;();

  myList.add('苹果');
  myList.add('西瓜');
  // myList.add(123); 无法存入int类型

  myList.printList(); // [苹果, 西瓜]
}

// 自定义一个泛型类，实现存入和打印的功能
class MyList&lt;E&gt; {
  List&lt;E&gt; _list = new List();

  add(E value) {
    this._list.add(value);
  }

  printList() {
    print(this._list.toString());
  }
}
</code></pre>
<h3 id="泛型接口">泛型接口</h3>
<p>示例需求：</p>
<blockquote>
<p>实现数据缓存功能：有文件缓存、内存缓存。内存缓存和文件缓存按照接口约束实现。</p>
<ol>
<li>定义一个泛型接口，约束实现它的子类必须有getByKey(key)和setByKey(key,value)</li>
<li>要求setByKey的是偶value的类型和实例化子类的时候指定的类型一致</li>
</ol>
</blockquote>
<pre><code class="language-dart">// 使用抽象类定义一个缓存接口，实现该接口的类必须实现setByKey()和getByKey()两个方法
abstract class Cache&lt;T&gt; {
  setByKey(String key, T value);
  T getByKey(String key);
}

// 定义一个内存缓存实现类，实现上面的缓存接口
class MemoryCache&lt;T&gt; implements Cache&lt;T&gt; {
  Map&lt;String, T&gt; _cache = new Map();

  @override
  T getByKey(String key) {
    return this._cache[key];
  }

  @override
  setByKey(String key, T value) {
    this._cache.addAll({key: value});
    print('add success');
  }
}

// 测试
void main() {
  var cache = new MemoryCache&lt;String&gt;();

  cache.setByKey('name', '张三'); // 打印 add success

  var name = cache.getByKey('name');
  print(name); // 张三
}
</code></pre>
<p>泛型的作用，当我们要定义一个只能存一种数据类型的容器，但不确定要存入的具体类型时，可以使用泛型。</p>
<p>使用泛型后，容器可以在具体实例化时指定容器的数据类型。</p>
<p>这解决了代码冗余，并对容器增加了数据校验（不确定数据的支持）。</p>
<h2 id="库">库</h2>
<p>在Dart中，每一个dart文件都是一个库。</p>
<p>Dart中主要有三种库：</p>
<ol>
<li>我们自定义库；</li>
<li>系统内置库；</li>
<li>Pub包管理系统中的库。</li>
</ol>
<p>在dart文件中，使用<code>import</code>关键字引入外部的库。</p>
<h3 id="引入自定义库">引入自定义库</h3>
<pre><code class="language-dart">import 'lib/Person.dart';
</code></pre>
<h3 id="引入系统内置库">引入系统内置库</h3>
<pre><code class="language-dart">import 'dart:io';
import 'dart:math';
</code></pre>
<p>如发起网络请求：</p>
<pre><code class="language-dart">import 'dart:convert';
import 'dart:io';

void main() async {
  var result = await _getDataFromZhihuAPI();
  print(result);
}

_getDataFromZhihuAPI() async {
  // 1. 创建HttpClient对象
  var httpClient = new HttpClient();
  // 2. 创建uri对象
  var uri = new Uri.http('www.shiguangping.com', '/');
  // 3. 发起请求，等待请求
  var request = await httpClient.getUrl(uri);
  // 4. 关闭请求，等待响应
  var response = await request.close();
  // 5. 解析响应的内容
  return await response.transform(utf8.decoder).join();
}
</code></pre>
<blockquote>
<p><code>async</code>和<code>await</code>关键字：</p>
<p><code>async</code>是让方法变成异步，<code>await</code>是等待异步方法执行完成。</p>
<p>只有<code>async</code>方法中才能使用<code>await</code>关键字，如果是调用其他的<code>async</code>方法必须使用<code>await</code>关键字。</p>
</blockquote>
<pre><code class="language-dart">// 异步方法
func() async {
  return '我是async方法';
}

void main() {
  // 调用异步方法需要获取返回值，需要使用await关键字 var res =  await func();
  var res = func();
  print('我是main方法');
  print(res); // Instance of 'Future&lt;dynamic&gt;'
}
</code></pre>
<h3 id="引入第三方库">引入第三方库</h3>
<p>从下面的网址获取常用的第三方库：</p>
<p><a href="https://pub.dev/packages">https://pub.dev/packages</a></p>
<p><a href="https://pub.flutter-io.cn/packages">https://pub.flutter-io.cn/packages</a></p>
<p><a href="https://pub.dartlang.org/flutter">https://pub.dartlang.org/flutter</a></p>
<p>项目中创建<code>pubspec.yaml</code>文件管理库依赖</p>
<pre><code class="language-yaml">name: xxx
description: A new flutter module project.
dependencies:
  http: ^0.12.2
</code></pre>
<p>安装第三方库的三步：</p>
<p>第一步：在<code>pubspec.yaml</code>的<code>dependencies</code>属性下添加要安装的库：</p>
<pre><code class="language-yaml">dependencies:
  http: ^0.12.2
</code></pre>
<p>第二步：执行命令：</p>
<pre><code class="language-bash">pub get
</code></pre>
<p>第三步：引入</p>
<pre><code class="language-dart">import 'package:http/http.dart';
</code></pre>
<h3 id="库的别名">库的别名</h3>
<p>引入的两个库如果存在相同的类名会存在冲突，可以使用<code>as</code>关键字为库起别名，使用<code>别名.类名</code>的方式引用库中的类。</p>
<pre><code class="language-dart">// 引入的两个库中都存在Person类，可以为库起别名，通过别名调用要使用的类
import 'lib/Person1.dart' as p1;
import 'lib/Person2.dart' as p2;

void main() {
  p1.Person person1 = new p1.Person();
  p2.Person person2 = new p2.Person();
}
</code></pre>
<h3 id="部分导入">部分导入</h3>
<p>如果只需要引入库中的一部分功能，有两种方式：</p>
<ul>
<li>
<p>只导入需要的部分，使用<code>show</code>关键字。引入多个使用<code>,</code>逗号分隔；</p>
<pre><code class="language-dart">// 使用 show 关键字 引入库中的部分功能
import 'lib/MyMath.dart' show getInt, getDouble;

void main() {
  getInt();
  getDouble();
  // getString();
}
</code></pre>
</li>
<li>
<p>隐藏不需要的部分，使用<code>hide</code>关键字</p>
<pre><code class="language-dart">// 使用 hide 关键字 隐藏库中不需要的功能
import 'lib/MyMath.dart' hide getInt, getDouble;

void main() {
  // getInt();
  // getDouble();
  getString();
}
</code></pre>
</li>
</ul>
<h3 id="延迟加载">延迟加载</h3>
<p>也称为懒加载，可以在需要的时候再进行加载。懒加载最大的好处是可以减少APP的启动时间。</p>
<p>懒加载使用<code>deferred as</code>关键字来指定，如下例子所示：</p>
<pre><code class="language-dart">import 'package:deferred/hello.dart deferred as hello';
</code></pre>
<p>当需要使用的时候，需要使用loadLibrary()方法来加载：</p>
<pre><code class="language-dart">greet() async {
  await hello.loadLibrary();
  hello.printGreeting();
}
</code></pre>
<h2 id="补充">补充</h2>
<h3 id="箭头函数">箭头函数</h3>
<p>Dart中的箭头<code>=&gt;</code>函数写法，如果方法体中只有一行代码，可以简写成箭头函数这种形式</p>
<pre><code class="language-dart">void main() {
  print('Hello Dart');
}

// 可以写成箭头函数的形式
void main() =&gt; {print('Hello Dart')};
</code></pre>
<ul>
<li>方法体中只有一行代码时可以写成箭头函数形式；</li>
<li>箭头函数后面的大括号可以省略，无论有无大括号，箭头函数后面只能有一行代码；</li>
<li>和JavaScript中的箭头函数用法不同。</li>
</ul>
<h2 id="结尾">结尾</h2>
<p>Dart语言部分至此告一段落，接下来开始进入Flutter阶段。</p>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
        <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div>
      </div>

      

      
        <div id="vlaine-comment"></div>
      

      <footer class="py-12 text-center px-4 md:px-0" v-pre>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">時光瓶</a>
</footer>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%85%A5%E5%8F%A3%E6%96%B9%E6%B3%95">入口方法</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>
<ul>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5">字符串拼接</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD">类型判断</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a></li>
</ul>
</li>
<li><a href="#list">List</a></li>
<li><a href="#map">Map</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a>
<ul>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a></li>
<li><a href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">关系运算符</a></li>
<li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li>
<li><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a></li>
</ul>
</li>
<li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">流程控制</a>
<ul>
<li><a href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">条件语句</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">循环语句</a>
<ul>
<li><a href="#break-%E5%85%B3%E9%94%AE%E5%AD%97">break 关键字</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88">集合</a>
<ul>
<li><a href="#list-2">List</a></li>
<li><a href="#set">Set</a></li>
<li><a href="#map-2">Map</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88">遍历集合</a>
<ul>
<li><a href="#map%E6%96%B9%E6%B3%95">map方法</a></li>
<li><a href="#where%E6%96%B9%E6%B3%95">where方法</a></li>
<li><a href="#any%E6%96%B9%E6%B3%95">any方法</a></li>
<li><a href="#every%E6%96%B9%E6%B3%95">every方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95">函数（方法）</a><br>
*
<ul>
<li><a href="#%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%9A%84%E6%96%B9%E6%B3%95">带有参数列表的方法</a></li>
<li><a href="#%E5%B8%A6%E6%9C%89%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95">带有可选参数的方法</a></li>
<li><a href="#%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95">带有默认参数的方法</a></li>
<li><a href="#%E5%B8%A6%E6%9C%89%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95">带有命名参数的方法</a></li>
<li><a href="#%E6%8A%8A%E6%96%B9%E6%B3%95%E5%BD%93%E5%81%9A%E5%8F%82%E6%95%B0%E4%BC%A0%E7%BB%99%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95">把方法当做参数传给一个方法</a></li>
<li><a href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95">匿名方法</a></li>
<li><a href="#%E8%87%AA%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95">自执行方法</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92">方法递归</a></li>
<li><a href="#%E9%97%AD%E5%8C%85">闭包</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB-%E5%AF%B9%E8%B1%A1">类 对象</a>
<ul>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%8C%96">实例化</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E7%B1%BB">定义类</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">默认构造函数</a></li>
<li><a href="#%E5%91%BD%E5%90%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">命名构造函数</a></li>
<li><a href="#%E5%BC%95%E5%85%A5dart%E6%96%87%E4%BB%B6">引入dart文件</a></li>
<li><a href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95">私有属性 私有方法</a></li>
<li><a href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">类中的初始化列表</a></li>
<li><a href="#static-%E5%85%B3%E9%94%AE%E5%AD%97">static 关键字</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E7%AC%A6">对象操作符</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3">实现多个接口</a></li>
<li><a href="#mixins">mixins</a></li>
</ul>
</li>
<li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a>
<ul>
<li><a href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">泛型方法</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB">泛型类</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">泛型接口</a></li>
</ul>
</li>
<li><a href="#%E5%BA%93">库</a>
<ul>
<li><a href="#%E5%BC%95%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93">引入自定义库</a></li>
<li><a href="#%E5%BC%95%E5%85%A5%E7%B3%BB%E7%BB%9F%E5%86%85%E7%BD%AE%E5%BA%93">引入系统内置库</a></li>
<li><a href="#%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93">引入第三方库</a></li>
<li><a href="#%E5%BA%93%E7%9A%84%E5%88%AB%E5%90%8D">库的别名</a></li>
<li><a href="#%E9%83%A8%E5%88%86%E5%AF%BC%E5%85%A5">部分导入</a></li>
<li><a href="#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD">延迟加载</a></li>
</ul>
</li>
<li><a href="#%E8%A1%A5%E5%85%85">补充</a>
<ul>
<li><a href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">箭头函数</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E5%B0%BE">结尾</a></li>
</ul>
</li>
</ul>

      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://www.shiguangping.com/media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  
    <script src="https://www.shiguangping.com/media/prism.js"></script>
    <script>
      Prism.highlightAll()
    </script>
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
  
    <script type="application/javascript" src="https://unpkg.com/valine"></script>
<script type="application/javascript">
  new Valine({
    el: '#vlaine-comment',
    appId: 'iScdY0hF5Y8TgKyMtfvp9CcM-gzGzoHsz',
    appKey: 'XH2m9KIiA88R6N2lYiSObDH7',
    pageSize: 10,
    notify: false,
    avatar: 'mp',
    verify: false,
    placeholder: '来都来了，不妨评论一下',
    visitor: true,
    highlight: false,
    recordIP: false,
  })
</script>
  
  
</body>

</html>