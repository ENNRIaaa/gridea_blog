<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>比特宇宙－TCP/IP的诞生 - 時光瓶</title>
<link rel="shortcut icon" href="https://ennriaaa.github.io/gridea_blog/favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://ennriaaa.github.io/gridea_blog/media/css/tailwind.css">
<link rel="stylesheet" href="https://ennriaaa.github.io/gridea_blog/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="比特宇宙－TCP/IP的诞生 - 時光瓶 - Atom Feed" href="https://ennriaaa.github.io/gridea_blog/atom.xml">

    

  <meta name="description" content="比特宇宙创世不久，宇宙中开始出现文明。
文明不断碰撞、融合、进化，逐渐分化为几大派系：
施行Unix体制的帝国，出现时间最早，在宇宙中最有威望。
施行Windows体制的帝国，数以十亿计，成为宇宙中最庞大的军团。
施行Linux体制的帝国，..." />
  <meta property="og:title" content="比特宇宙－TCP/IP的诞生 - 時光瓶">
  <meta property="og:description" content="比特宇宙创世不久，宇宙中开始出现文明。
文明不断碰撞、融合、进化，逐渐分化为几大派系：
施行Unix体制的帝国，出现时间最早，在宇宙中最有威望。
施行Windows体制的帝国，数以十亿计，成为宇宙中最庞大的军团。
施行Linux体制的帝国，..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://ennriaaa.github.io/gridea_blog/post/tcpip-birth-talk-talk/" />
  <meta property="og:image" content="https://ennriaaa.github.io/gridea_blog/images/avatar.png">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="比特宇宙－TCP/IP的诞生 - 時光瓶">
  <meta name="twitter:description" content="比特宇宙创世不久，宇宙中开始出现文明。
文明不断碰撞、融合、进化，逐渐分化为几大派系：
施行Unix体制的帝国，出现时间最早，在宇宙中最有威望。
施行Windows体制的帝国，数以十亿计，成为宇宙中最庞大的军团。
施行Linux体制的帝国，...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://ennriaaa.github.io/gridea_blog/post/tcpip-birth-talk-talk/">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  
    <link rel="stylesheet" href="https://ennriaaa.github.io/gridea_blog/media/css/prism-atom-dark.css">
  

  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://ennriaaa.github.io/gridea_blog" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      時光瓶
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          比特宇宙－TCP/IP的诞生
        </h1>
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">2020-09-28 · 13 min read</div>
          
            <a href="https://ennriaaa.github.io/gridea_blog/tag/KuMB9r-ja/" class="text-gray-700 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
              <i class="ri-hashtag"></i>
              TCP/IP
            </a>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <p>比特宇宙创世不久，宇宙中开始出现文明。</p>
<p>文明不断碰撞、融合、进化，逐渐分化为几大派系：</p>
<p>施行Unix体制的帝国，出现时间最早，在宇宙中最有威望。</p>
<p>施行Windows体制的帝国，数以十亿计，成为宇宙中最庞大的军团。</p>
<p>施行Linux体制的帝国，后起之秀，曾和Windows帝国军团爆发多次战争，后握手言和，割据一方。</p>
<p>随着文明的发展，宇宙之间的各帝国逐渐意识到需要发展经贸合作，互通有无。终于有一天，几大派系的帝国派了代表聚在一起，商讨比特宇宙的经贸合作框架协议。</p>
<p><strong>☆ 第一天 ☆</strong></p>
<p>会议第一天的议题，商讨经贸合作的最重要的基础：制定比特宇宙通信标准。</p>
<p>Unix代表首先发言：我们需要制定一套普世的宇宙标准，让全宇宙的帝国都能互相通信，大家有什么想法，请畅所欲言。</p>
<p>Linux：最简单有效的办法，帝国之间都建一条专有线路，就像这样，构成一张巨大的网络，我们就能和任何帝国通信了。</p>
<img src="https://images.shiguangping.com/imgs/20200928132850.png" alt="img" style="zoom:50%;" />
<p>Windows：你想的也太简单了，你知道咱们Windows星系有多少帝国吗？建专有线路，这得花多少钱？就算你有钱，帝国要建这么多线路，那也不堪重负。<br>
Linux：别着急，我还有办法。咱们找一个帝国作为网络中心节点，专门负责数据转发，其他帝国只需和中心建一条专线就可以，这一下能省很多线路的钱。诺，就像这样：</p>
<img src="https://images.shiguangping.com/imgs/20200928132858.png" alt="img" style="zoom:50%;" />
<p>Windows：确实省了不少，但你有没有想过，这个中心节点得多么重要，工作负担巨大倒是其次，一旦中心帝国覆灭，全宇宙的通信全部中断，这是多么严重的后果？Linux皱了眉头，不再说话。</p>
<p>Unix：其实这个方法挺不错的，不过需要一点改进会更好。就像你说的，一个中心节点不够，咱们可以弄多个啊，然后这多个中心节点之间再互相连接，把一个中心变成多个中心。嗯，其实这里就不再存在中心了，就是一个去中心的分布式网络了，你们觉得怎么样？</p>
<img src="https://images.shiguangping.com/imgs/20200928132907.png" alt="img" style="zoom:50%;" />
<p>Linux：唉，这个好！我还想到了一招，既然咱们宇宙中帝国众多，就把你说的中间这些节点再进一步划分层级，也就是划分为一个个子网络，然后子网之间连接组成大的网络，然后大的网络之间再连接构成更大的网络！我是不是个天才！</p>
<img src="https://images.shiguangping.com/imgs/20200928132915.png" alt="img" style="zoom:50%;" />
<p>Windows：嗯，听起来挺不错的，不过有一个问题还没解决，就是非常遥远的两个帝国之间要通信，网络通道该怎么建立呢？中间节点要如何给这两个帝国搭建出一条专线，让他们通信呢？</p>
<p>·······一阵沉默·····</p>
<p>·Unix：为什么非得建立专线呢？这样效率太低了，如果一条线路给你们占用了，别人要经过这条线的是不是得一直等着？</p>
<p>Linux：说的有道理，那你有什么好主意？</p>
<p>Unix：我们可以把数据拆分为一个个的单元，分组传输，每个单元写好发件人、收件人，中间的节点负责存储转发就可以了嘛，这样大家都可以用这个网络，效率大大提升。</p>
<p>Windows代表拍案而起，“这简直是划时代的想法！大佬果然是大佬！”</p>
<p>Linux：非常棒的想法，我们给这种技术取个名字吧，既然是分组，然后存储转发，要不然叫”分组交换技术“怎么样？</p>
<p>Unix：嗯，这名字很贴切，就叫它！</p>
<p>Linux：我们给这个巨大的网络也取一个名字吧，叫Internet怎么样？</p>
<p>Unix：Internet，因特网，听起来还不错</p>
<img src="https://images.shiguangping.com/imgs/20200928132927.png" alt="img" style="zoom:50%;" />
<p>Windows：大佬，既然要通信，接下来咱们需要要讨论下通信协议了吧。</p>
<p>Unix：通信协议？</p>
<p>Windows：对啊，咱们得制定一套规范标准，所有帝国按照这套规范来收发信息，才能互相理解对方在说什么。</p>
<p>Unix：嗯，确实需要这么一套标准协议。既然网络叫Internet，那咱这套标准协议就叫Internet Protocol，那具体协议内容怎么制定呢？</p>
<p>Linux：等下，给我个表现机会，让我先说说。</p>
<p>Windows：洗耳恭听。</p>
<p>Linux：咱们给所有帝国编一个号，用4个字节的整数来表示，嗯，我想想，从0x00000000到0xFFFFFFFF，差不多能表示42亿多个帝国了，绰绰有余了。这个编号，就叫Internet Protocol Address，也就是IP地址。</p>
<p>Windows：嗯，用是够用了，不过我建议不要用16进制表示，不太好书写，人类那智商肯定记不住。既然是4个字节整数，要不就用人类熟悉的4个十进制整数来写，用点来隔开，像这样：0.0.0.0～255.255.255.255，把这种写法叫做IP地址的点分十进制表示法，怎么样？**<br>
**</p>
<p>Linux：嗯，这个建议好，可以采纳。我刚才还没讲完，通信的时候，数据前面加一个头部，头部里面写上发件人的IP地址、收件人的IP地址，这样发送出去，然后交给网络中的中间节点，让他们转发出去...</p>
<p>Windows：等一下，有一个问题，中间节点该如何知道转发给谁呢？·······又是一阵沉默······</p>
<p>Linux：有了，人类收发快递的时候，他们的地址是分了省，市，县到街道，一层层分级了，逐级进入就能找到收件人的地方。咱们的网络也可以这样效仿，把网络分不同大区，大区里面分子网。然后负责转发的这些中间节点，记录一张表，表里面记录不同地区的地址该交给谁，如此，不同层级负责不同的地区，整个网络就能运转起来，收发信息了。</p>
<p>Unix：这个办法好，咱就把这种技术叫路由技术，这个表叫做路由表。</p>
<p>Windows：确实很有头脑嘛，不过我想到有一种情况可能可能比较难办。</p>
<p>Linux：什么情况，别卖关子了。<br>
Windows：如果写了一个不存在的收件人，或者是中间节点的路由表里面都没有记录这个帝国，甚至有些中间节点之间踢皮球，谁都不知道交给谁，互相推诿，那发出去的数据包裹岂不是要在网络里面转圈圈，没完没了浪费资源了？<br>
Linux：额，好像确实是有这么个麻烦问题，你解决问题没啥能力，挑刺倒是一把好手嘛！</p>
<p>Unix：有了！咱们在在这个头部里面除了写上收发地址外，再加一个计数器，表示这个包裹的生命周期，发件人初始设置一个数字，表示允许最多在网络中传递几次。中间节点收到后，就把数字减1，如果某个节点拿到后发现减1后变成0，那就丢掉它不再传输了</p>
<p>Linux：嗯，这个办法好，这个计数器也取一个名字，叫Time to Live吧，就是生存时间的意思，简写成<strong>TTL</strong>。</p>
<p>Windows：大佬，果然有经验，佩服佩服。不过原谅我还要继续提问题哦。</p>
<p>Linux：你的问题怎么这么多，快说！<br>
Windows：帝国之内有许多的公司都需要经贸合作，如何能进一步区分是哪家公司的信息呢？</p>
<p>Linux：这样看来，4个字节整数不够用啊，再加一点怎么样，给每个公司都弄一个编号。</p>
<p>Windows：这恐怕不太现实，帝国的公司经常在变化，每天诞生消亡不计其数，还有些公司根本不做国际化贸易，不需要网络通信，这种办法不好操作。</p>
<p>Linux：这，，，</p>
<p>Unix：今天时间也不早了，要不明天继续讨论这个议题如何，今天的收获已经不少了。</p>
<p>Linux：好的，我回去再琢磨琢磨。</p>
<p><strong>☆ 第二天 ☆</strong></p>
<p>Unix：两位昨晚休息的如何？</p>
<p>Windows：还不错。</p>
<p>Linux：还行吧，对了，昨天最后那个问题我有新的解决方案了。</p>
<p>Windows：哦，是吗，我也想到了一个办法，要不你先说。</p>
<p>Linux：昨天的IP地址技术方案还是不变，IP地址只用来在网络中标识一个帝国，至于帝国内部的公司，由帝国内部自己管理。帝国内部再给自己的公司编个码，既然你说到公司会不断消亡和诞生，那这个号码就动态生成。</p>
<p>Windows：跟我想的差不多，帝国负责网络通信的部门给需要通信的公司分配一个号码，我取名叫端口号，用2个字节来表示，总共65535个端口号，公司要通信的时候，向帝国网络通信部门申请，用完就回收。通信过程中，把这个端口号也带上，帝国网络通信部门收到来自网络的信息包裹后，根据上面收件人的端口号，就能交给具体业务的公司了！<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" loading="lazy"></p>
<img src="https://images.shiguangping.com/imgs/20200928132935.png" alt="img" style="zoom:50%;" />
<p>Linux：对对对，跟我想的简直一摸一样！</p>
<p>Unix：嗯，不错不错，其实我也想到了这个办法。好了现在怎么通信的问题解决了，大家觉得我们的标准还差什么不？</p>
<p>Linux：我觉得整体框架已经很完善了，有一个可以再优化一点的地方。</p>
<p>Unix：额哦，是什么呢？</p>
<p>Linux：目前的方案通信是没有问题了，但因为咱们的包裹都是拆开了一个个发，由于中间网络的路况变化，可能后发的先到，有些还可能丢掉了，需要补发，还有可能发重复了，还有可能后面发的优先级更高，需要加快处理等等各种复杂的情况其实还挺多的，咱们可能还得想一套办法来解决这个问题。</p>
<img src="https://images.shiguangping.com/imgs/20200928132944.png" alt="img" style="zoom: 67%;" />
<p>Unix：呀，听你这么一说，我瞬间觉得问题还挺大的啊</p>
<p>Windows：看来简单的分组转发还不行，得有一套传输控制协议，来专门来解决上面的问题。</p>
<p>Linux：是的，你继续说下去。</p>
<p>Windows：我们来改造下原来的IP协议，除了把刚才说到的端口号也加进去，同时再设置一些标记，对包裹编号，这样收到后才好排序，去重。</p>
<p>Linux：嗯，想法不错，不过我不建议改造原来的IP协议，IP协议只负责帝国之间的传送，负责网络路由送达，至于数据的问题，不应该他来负责。我建议在IP协议后面再扩展一层出来，单独来做传输控制。</p>
<p>Unix：嗯， 我同意，不要把所有事情都搅合在一起，分层处理，每层只负责自己的职责。</p>
<p>Windows：也好，我也同意。</p>
<p>Linux：不过如何知道包裹丢失呢？</p>
<p>Windows：要不然这样，收到包裹后，得给一个答复，告诉发件人我收到了。</p>
<p>Linux：那其他问题呢？</p>
<p>Windows：额，暂时还没想好。</p>
<p>Unix：让我也出出注意，我们给这些数据包裹再加一些标志字段，用来对数据包裹进行编号，发送速度调节，优先级标识等等。</p>
<p>Windows：看起来可行，不过这双方可能在传输数据之前得先做些初始化工作。</p>
<p>Linux：嗯，要不在通信之前，双方先建立一个连接Unix：连接，怎么又要建立连接，不是分组转发吗？</p>
<p>Windows：是啊，你要开倒车吗？</p>
<p>Linux：两位先别急，此连接非彼连接，这是一个逻辑上的虚拟连接。正式通信之前先确认网络通达性，彼此做好初始化操作，可以理解为通过网络远程握手。通信完成后，再断开连接。</p>
<img src="https://images.shiguangping.com/imgs/20200928133000.png" alt="img" style="zoom:50%;" />
<p>​</p>
<img src="https://images.shiguangping.com/imgs/20200928133008.png" alt="img" style="zoom:50%;" />
<p>Windows：这样啊，倒是一个好办法。不过感觉这一套工作下来挺复杂的，有些公司业务比较简单，数据量小，信息包裹丢失大不了一会儿重发，弄这些感觉成本高，不一定所有公司会买账。</p>
<p>Unix：你说的这种情况也确实存在，要不这些比较简单的业务就不要走这套流程了，不用这套控制传输协议，单独弄一个简单版本的。</p>
<p>Linux：老大说的在理，刚才这套复杂的协议咱们取名叫TCP协议，就是传输控制协议的意思，老大说的简单版本的要不叫UDP，用户数据报协议，只记录收发公司的端口号就行，非常简单。</p>
<p>Unix：非常好，就这么愉快的决定了！<br>
Linux：老大，咱们这套标准改个名吧，叫TCP/IP协议如何？</p>
<p>Windows：这是两个协议，加上其他协议，这是一个家族了，应该叫TCP/IP协议族。</p>
<p>Unix：同意！应该叫协议族才对！</p>
<img src="https://images.shiguangping.com/imgs/20200928133032.png" alt="img" style="zoom:67%;" />
<p>第三天，Unix、Linux、Windows三大帝国集团代表发布《关于比特宇宙推进经贸合作的联合声明》，比特宇宙迎来全新的历史时期！</p>
<p>会议达成的网络通信标准TCP/IP协议族很快在比特宇宙中流行开来，无数的帝国纷纷拥抱因特网，没过多久，各种各样的网络业务便发展起来，因特网一片欣欣向荣。这其中发展最为迅速的要数Web业务，无数的帝国通过因特网相连，传输网页供人类浏览，后来人类又给他们取了一个新名字：互联网。</p>
<hr>
<p><strong>转载自<a href="https://www.cnblogs.com/xuanyuan/p/12009338.html">https://www.cnblogs.com/xuanyuan/p/12009338.html</a></strong></p>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
        <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div>
      </div>

      

      
        <div id="vlaine-comment"></div>
      

      <footer class="py-12 text-center px-4 md:px-0" v-pre>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">時光瓶</a>
</footer>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        
      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://ennriaaa.github.io/gridea_blog/media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  
    <script src="https://ennriaaa.github.io/gridea_blog/media/prism.js"></script>
    <script>
      Prism.highlightAll()
    </script>
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
  
    <script type="application/javascript" src="https://unpkg.com/valine"></script>
<script type="application/javascript">
  new Valine({
    el: '#vlaine-comment',
    appId: 'iScdY0hF5Y8TgKyMtfvp9CcM-gzGzoHsz',
    appKey: 'XH2m9KIiA88R6N2lYiSObDH7',
    pageSize: 10,
    notify: false,
    avatar: 'mp',
    verify: false,
    placeholder: '来都来了，不妨评论一下',
    visitor: true,
    highlight: false,
    recordIP: false,
  })
</script>
  
  
</body>

</html>